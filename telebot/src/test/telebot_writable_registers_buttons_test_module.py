import re

from typing import List

from telebot_menu_item import TelebotMenuItem
from telebot_test_users import TelebotTestUsers
from deye_register import DeyeRegister
from deye_registers import DeyeRegisters
from solarman_server import SolarmanServer
from deye_base_enum import DeyeBaseEnum
from telebot_base_test_module import TelebotBaseTestModule
from testable_telebot import TestableTelebot

class TelebotWritableRegistersButtonsTestModule(TelebotBaseTestModule):
  """
  Module `TelebotWritableRegistersButtonsTestModule` tests the correctness of
  **command buttons** generated by the Telegram bot for writable Deye registers.

  The goal is to ensure that all buttons have valid command formats and values
  consistent with the register type and range.

  **Test flow:**
  - Iterates through all writable registers.  
  - Sends a command to the bot to display available buttons.  
  - Validates each button to ensure:
    - It starts with `/` and contains a space.  
    - The command name matches the register name.  
    - The value matches the register's type and is within valid limits.  
    - Enum values are known and valid.  
  - Special system commands are ignored during checks.

  This module ensures that all generated command buttons are properly formatted
  and correspond to valid register operations.
  """
  def __init__(self, bot: TestableTelebot):
    super().__init__(bot)

  @property
  def description(self) -> str:
    return 'writable registers buttons test'

  def run_tests(self, servers: List[SolarmanServer]):
    if not self.loggers.is_test_loggers:
      self.error('Your loggers are not test loggers')

    user = TelebotTestUsers().test_user1
    registers = DeyeRegisters()

    def throw(reg: DeyeRegister, cmd: str, text: str):
      self.error(f"Wrong command button '{cmd}' for register '{reg.name}'. {text}")

    for register in registers.all_registers:
      if not register.can_write:
        continue

      command = f'/{register.name}'

      self.log.info(f"Processing register '{register.name}' with value type {type(register.value).__name__}...")
      self.log.info(f"Sending command '{command}'")

      self.send_text(user, command)
      data = self.wait_for_text_regex_and_get_buttons_data(rf'Current.+{register.description}.+value.*Enter new value')

      for cmd_str in data:
        if not cmd_str.startswith('/'):
          throw(register, cmd_str, 'Command should start with /')

        if cmd_str == f'/{TelebotMenuItem.deye_sync_time.command}':
          continue

        if ' ' not in cmd_str:
          throw(register, cmd_str, 'Command should contain space')

        cmd, value = cmd_str.lstrip('/').split(' ', 1)

        if cmd != register.name:
          throw(register, cmd_str, 'Command name should match register name')

        if isinstance(register.value, int):
          if not re.fullmatch(r'[+-]?\d+', value):
            throw(register, cmd_str, 'Command value should be int')
          if int(value) < register.min_value or int(value) > register.max_value:
            throw(register, cmd_str, f'Command value should be from {register.min_value} to {register.max_value}')
        elif isinstance(register.value, float):
          if not re.fullmatch(r'[+-]?\d+(\.\d{1,2})?', value):
            throw(register, cmd_str, 'Command value should be int or float with maximum two signs')
          if float(value) < register.min_value or float(value) > register.max_value:
            throw(register, cmd_str, f'Command value should be from {register.min_value} to {register.max_value}')
        elif isinstance(register.value, DeyeBaseEnum):
          if register.value.parse(value).is_unknown:
            throw(register, cmd_str, f"Enum value '{value}' is unknown")

    self.log.info('Seems all registers have correct buttons')
